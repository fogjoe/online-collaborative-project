è¿™æ˜¯ä¸€ä¸ªéå¸¸æ£’çš„ç›®æ ‡ï¼ä»å‰ç«¯å¼€å‘è€…è½¬å‹ä¸ºå…¨æ ˆå¼€å‘è€…ï¼Œæœ€å¥½çš„æ–¹å¼å°±æ˜¯é€šè¿‡ä¸€ä¸ªå®Œæ•´çš„é¡¹ç›®æ¥é©±åŠ¨å­¦ä¹ ã€‚ä½ åˆ—å‡ºçš„æŠ€æœ¯æ ˆéå¸¸å…¨é¢ï¼Œæ¶µç›–äº†ç°ä»£ Web å¼€å‘çš„ç»å¤§éƒ¨åˆ†æ ¸å¿ƒç»„ä»¶ã€‚

ä¸ºäº†èƒ½æŠŠæ‰€æœ‰è¿™äº›æŠ€æœ¯ï¼ˆReact, åç«¯, SQL, NoSQL, Redis, Nginx, DevOpsï¼‰éƒ½â€œä¸²â€èµ·æ¥ï¼Œä½ éœ€è¦ä¸€ä¸ªæ•°æ®é©±åŠ¨ã€é«˜å¹¶å‘ã€å¤šåŠŸèƒ½çš„é¡¹ç›®ã€‚

æˆ‘æ¨èä½ åšä¸€ä¸ª â€œåœ¨çº¿åä½œå¼é¡¹ç›®ç®¡ç†å·¥å…·â€ï¼ˆç±»ä¼¼ä¸€ä¸ªæç®€ç‰ˆçš„ Trello æˆ– Asanaï¼‰ã€‚

ä¸ºä»€ä¹ˆæ˜¯è¿™ä¸ªé¡¹ç›®ï¼Ÿå› ä¸ºå®ƒå¤©ç„¶åœ°å¥‘åˆä½ æ‰€æœ‰çš„å­¦ä¹ éœ€æ±‚ã€‚

ä¸‹é¢æˆ‘å°†ä¸ºä½ åˆ†è§£ï¼Œè¿™ä¸ªé¡¹ç›®å¦‚ä½•è®©ä½ é€ä¸€æ”»å…‹ä½ æåˆ°çš„æ‰€æœ‰æŠ€æœ¯ç‚¹ï¼š

ğŸ—‚ï¸ é¡¹ç›®æ¨èï¼šåœ¨çº¿åä½œå¼é¡¹ç›®ç®¡ç†å·¥å…·
ä¸€ä¸ªç”¨æˆ·å¯ä»¥æ³¨å†Œè´¦æˆ·ï¼Œåˆ›å»ºâ€œé¡¹ç›®ç©ºé—´â€ï¼ˆProjectï¼‰ï¼Œåœ¨ç©ºé—´å†…åˆ›å»ºâ€œçœ‹æ¿â€ï¼ˆBoardï¼‰ï¼Œåœ¨çœ‹æ¿ä¸Šæ·»åŠ â€œä»»åŠ¡å¡ç‰‡â€ï¼ˆCardï¼‰ï¼Œå¹¶å¯ä»¥æ‹–æ‹½å¡ç‰‡ã€åˆ†é…ç»™ä»–äººã€å‘è¡¨è¯„è®ºã€‚

ğŸ› ï¸ å¦‚ä½•åº”ç”¨ä½ æåˆ°çš„æŠ€æœ¯æ ˆ
1. å‰ç«¯ (Frontend - React)
è¿™æ˜¯ä½ çš„å¼ºé¡¹ã€‚

åŠŸèƒ½: ç”¨æˆ·æ³¨å†Œ/ç™»å½•ã€é¡¹ç›®ä»ªè¡¨ç›˜ã€çœ‹æ¿ç•Œé¢ï¼ˆåˆ—å’Œå¡ç‰‡ï¼‰ã€å¡ç‰‡è¯¦æƒ…å¼¹çª—ã€‚

æ ¸å¿ƒæŒ‘æˆ˜: ä½¿ç”¨ react-beautiful-dnd åº“å®ç°å¡ç‰‡çš„æ‹–æ‹½åŠŸèƒ½ã€‚

è¿›é˜¶: ä½¿ç”¨ WebSocket å®ç°å®æ—¶åä½œï¼ˆå½“ä¸€ä¸ªç”¨æˆ·æ‹–æ‹½å¡ç‰‡æ—¶ï¼Œçœ‹æ¿ä¸Šçš„å…¶ä»–ç”¨æˆ·èƒ½å®æ—¶çœ‹åˆ°å˜åŒ–ï¼‰ã€‚

2. åç«¯ (Backend)
ä½ å¯¹åç«¯è¯­è¨€ä¸ç†Ÿï¼Œè¿™å¯¹ä½ æ¥è¯´æ˜¯æœ€å¥½çš„æœºä¼šã€‚

æ¨è: Node.js (ä½¿ç”¨ NestJS æ¡†æ¶)

ä¸ºä»€ä¹ˆ? ä½ å·²ç»æ˜¯å‰ç«¯å¼€å‘è€…ï¼Œç†Ÿæ‚‰ JavaScript/TypeScriptã€‚ä½¿ç”¨ Node.js å¯ä»¥è®©ä½ æ— ç¼åˆ‡æ¢åˆ°åç«¯ï¼Œä¸“æ³¨äºå­¦ä¹ åç«¯çš„â€œæ€æƒ³â€ï¼ˆå¦‚ API è®¾è®¡, ä¸­é—´ä»¶, èº«ä»½éªŒè¯, ORMï¼‰ï¼Œè€Œä¸æ˜¯çº ç»“äºä¸€é—¨å…¨æ–°çš„è¯­è¨€ã€‚

åŠŸèƒ½:

REST API: ç”¨äºæ‰€æœ‰ CRUD æ“ä½œï¼ˆåˆ›å»ºé¡¹ç›®ã€è·å–å¡ç‰‡ã€æ›´æ–°ä»»åŠ¡çŠ¶æ€ç­‰ï¼‰ã€‚

WebSocket API: ç”¨äºå®æ—¶é€šçŸ¥ï¼ˆä¾‹å¦‚ï¼Œä½¿ç”¨ socket.ioï¼‰ã€‚

èº«ä»½éªŒè¯: ä½¿ç”¨ JWT (JSON Web Tokens) å®ç°ç”¨æˆ·ç™»å½•å’Œ API ä¿æŠ¤ã€‚

3. æ•°æ®åº“ (SQL - PostgreSQL æˆ– MySQL)
æ¨è: PostgreSQL (PgSql)ï¼Œå®ƒçš„åŠŸèƒ½æ›´å¼ºå¤§ã€‚

ç”¨é€”: å­˜å‚¨ä½ çš„æ ¸å¿ƒç»“æ„åŒ–æ•°æ®ã€‚è¿™äº›æ•°æ®å…³ç³»æ¸…æ™°ï¼Œéå¸¸é€‚åˆ SQLã€‚

æ•°æ®è¡¨ (Tables):

Users: (id, username, password_hash, email)

Projects: (id, name, owner_id)

Boards: (id, name, project_id)

Lists: (id, name, board_id, order)

Cards: (id, title, description, list_id, order)

User_Projects (å…³è”è¡¨): (user_id, project_id) - ç”¨äºå¤„ç†â€œè°åœ¨å“ªä¸ªé¡¹ç›®é‡Œâ€ã€‚

4. æ•°æ®åº“ (NoSQL - MongoDB)
ç”¨é€”: å­˜å‚¨éç»“æ„åŒ–æˆ–åŠç»“æ„åŒ–æ•°æ®ã€‚

åŠŸèƒ½:

æ´»åŠ¨æ—¥å¿— (Activity Logs): è¿™æ˜¯ä¸€ä¸ªå®Œç¾çš„åº”ç”¨åœºæ™¯ã€‚â€œå¼ ä¸‰ åœ¨ 10:05 å°†å¡ç‰‡ â€˜Aâ€™ ç§»åŠ¨åˆ°äº† â€˜å·²å®Œæˆâ€™â€ã€‚è¿™ç§æµæ°´æ•°æ®ç”¨ NoSQL å­˜å‚¨éå¸¸æ–¹ä¾¿ã€‚

å¡ç‰‡è¯„è®º (Comments): è¯„è®ºçš„ç»“æ„å¯ä»¥å¾ˆçµæ´»ï¼Œä¹Ÿå¯ä»¥å­˜åœ¨è¿™é‡Œã€‚

ç”¨æˆ·åå¥½è®¾ç½®: ä¾‹å¦‚ç”¨æˆ·çš„ä¸»é¢˜é¢œè‰²ã€é€šçŸ¥å¼€å…³ç­‰ã€‚

5. ç¼“å­˜ (Caching - Redis)
ç”¨é€”: æå‡æ€§èƒ½ï¼Œå‡å°‘æ•°æ®åº“å‹åŠ›ã€‚

åŠŸèƒ½:

Session å­˜å‚¨: å­˜å‚¨ç”¨æˆ·çš„ç™»å½•çŠ¶æ€ï¼ˆSessionï¼‰ï¼Œæ¯”å­˜åœ¨æ•°æ®åº“é‡Œå¿«å¾—å¤šã€‚

æ•°æ®ç¼“å­˜: æ¯”å¦‚â€œé¡¹ç›®ä»ªè¡¨ç›˜â€æˆ–â€œé¦–é¡µâ€çš„æ•°æ®ä¸å¸¸å˜åŠ¨ï¼Œå¯ä»¥æŠŠæŸ¥è¯¢ç»“æœç¼“å­˜åœ¨ Redis ä¸­ 5 åˆ†é’Ÿï¼Œæå¤§æé«˜åŠ è½½é€Ÿåº¦ã€‚

API é€Ÿç‡é™åˆ¶ (Rate Limiting): é™åˆ¶æŸä¸ªç”¨æˆ·æˆ– IP æ¯åˆ†é’Ÿè°ƒç”¨ API çš„æ¬¡æ•°ï¼Œé˜²æ­¢æ¶æ„æ”»å‡»ã€‚

6. Web æœåŠ¡å™¨ (Web Server - Nginx)
ç”¨é€”: ä½œä¸ºä½ æ•´ä¸ªåº”ç”¨çš„â€œæ€»å‰å°â€å’Œâ€œäº¤é€šæŒ‡æŒ¥â€ã€‚

åŠŸèƒ½:

åå‘ä»£ç† (Reverse Proxy): è¿™æ˜¯ Nginx æœ€æ ¸å¿ƒçš„ç”¨é€”ã€‚

å½“ç”¨æˆ·è®¿é—® your-domain.com æ—¶ï¼ŒNginx è½¬å‘è¯·æ±‚åˆ°ä½ çš„ React å‰ç«¯åº”ç”¨ã€‚

å½“ç”¨æˆ·è®¿é—® your-domain.com/api/... æ—¶ï¼ŒNginx è½¬å‘è¯·æ±‚åˆ°ä½ çš„ Node.js åç«¯æœåŠ¡ã€‚

é™æ€æ–‡ä»¶æœåŠ¡: Nginx å¯ä»¥æé€Ÿåœ°æä¾›ä½ çš„ React build åçš„ main.js, style.css ç­‰é™æ€æ–‡ä»¶ï¼Œæ¯” Node.js å»åšè¿™ä»¶äº‹å¿«å¾—å¤šã€‚

è´Ÿè½½å‡è¡¡: (è¿›é˜¶) å½“ä½ æœªæ¥æŠŠåç«¯éƒ¨ç½²åˆ° 2 å°æœåŠ¡å™¨ä¸Šæ—¶ï¼ŒNginx å¯ä»¥æŠŠæµé‡åˆ†å‘ç»™å®ƒä»¬ã€‚

SSL ç»ˆæ­¢: é…ç½® HTTPSï¼Œè®©ä½ çš„ç½‘ç«™æ›´å®‰å…¨ã€‚

7. éƒ¨ç½²ä¸ DevOps
æ ¸å¿ƒå·¥å…·: Docker

ä¸ºä»€ä¹ˆ? ä½ çš„é¡¹ç›®ç°åœ¨æœ‰è‡³å°‘ 5 ä¸ªâ€œæœåŠ¡â€ï¼šReact, Node.js, PostgreSQL, MongoDB, Redisã€‚åœ¨æœ¬åœ°å¼€å‘å’Œéƒ¨ç½²åˆ°æœåŠ¡å™¨æ—¶ï¼Œç®¡ç†å®ƒä»¬ä¼šæ˜¯å™©æ¢¦ã€‚

Docker çš„ç”¨é€”:

å®¹å™¨åŒ– (Containerization): ä½ ä¼šä¸ºä½ çš„ React åº”ç”¨å†™ä¸€ä¸ª Dockerfileï¼Œä¸ºä½ çš„ Node.js åº”ç”¨å†™ä¸€ä¸ª Dockerfileã€‚

Docker Compose: ä½ ä¼šå†™ä¸€ä¸ª docker-compose.yml æ–‡ä»¶ï¼Œç”¨ä¸€æ¡å‘½ä»¤ (docker-compose up) å°±èƒ½åœ¨æœ¬åœ°åŒæ—¶å¯åŠ¨å’Œè¿æ¥æ‰€æœ‰æœåŠ¡ï¼ˆåŒ…æ‹¬æ•°æ®åº“å’Œ Redisï¼‰ã€‚

CI/CD (æŒç»­é›†æˆ/æŒç»­éƒ¨ç½²):

ä½¿ç”¨ GitHub Actionsã€‚

æµç¨‹: å½“ä½  git push ä»£ç åˆ° main åˆ†æ”¯æ—¶ï¼š

GitHub Actions è‡ªåŠ¨è¿è¡Œï¼ˆä¾‹å¦‚ npm testï¼‰ã€‚

è‡ªåŠ¨æ„å»ºä½ çš„ Docker é•œåƒã€‚

è‡ªåŠ¨å°†æ–°é•œåƒæ¨é€åˆ° Docker Hubï¼ˆé•œåƒä»“åº“ï¼‰ã€‚

(è¿›é˜¶) è‡ªåŠ¨ç™»å½•åˆ°ä½ çš„æœåŠ¡å™¨ï¼ˆå¦‚ AWS, Vultr, DigitalOceanï¼‰ï¼Œæ‹‰å–æœ€æ–°é•œåƒå¹¶é‡å¯æœåŠ¡ã€‚

ğŸ—ºï¸ å»ºè®®çš„è¡ŒåŠ¨è·¯å¾„
ä¸è¦è¯•å›¾ä¸€æ¬¡æ€§å­¦ä¹ æ‰€æœ‰ä¸œè¥¿ã€‚ä½ åº”è¯¥åˆ†é˜¶æ®µæ„å»ºï¼š

é˜¶æ®µ 1 (åç«¯ API): å¯åŠ¨ NestJS é¡¹ç›®ã€‚è®¾è®¡ API è·¯ç”±ï¼Œç”¨ PostgreSQL è·‘é€š Users å’Œ Projects çš„ CRUDã€‚

é˜¶æ®µ 2 (å‰åç«¯è¿æ¥): å¯åŠ¨ React é¡¹ç›®ã€‚å®ç°æ³¨å†Œã€ç™»å½•ï¼ˆå¯¹æ¥åç«¯ JWT è®¤è¯ï¼‰ï¼Œå¹¶å±•ç¤ºé¡¹ç›®åˆ—è¡¨ã€‚

é˜¶æ®µ 3 (æ ¸å¿ƒåŠŸèƒ½): å®ç°çœ‹æ¿ã€åˆ—è¡¨å’Œå¡ç‰‡çš„ CRUDã€‚å®ç°æ‹–æ‹½åŠŸèƒ½ã€‚

é˜¶æ®µ 4 (Docker åŒ–): å­¦ä¹  Dockerï¼Œä¸ºå‰åç«¯ç¼–å†™ Dockerfileï¼Œå¹¶ä½¿ç”¨ docker-compose.yml åœ¨æœ¬åœ°æŠŠå®ƒä»¬å’Œæ•°æ®åº“ä¸€èµ·è·‘èµ·æ¥ã€‚

é˜¶æ®µ 5 (éƒ¨ç½²): ç§Ÿä¸€å°äº‘æœåŠ¡å™¨ (VPS)ï¼Œå®‰è£… Dockerï¼ŒæŠŠä½ çš„ docker-compose.yml è·‘èµ·æ¥ï¼Œé…ç½® Nginx åå‘ä»£ç†ã€‚

é˜¶æ®µ 6 (æ€§èƒ½ä¼˜åŒ–): å¼•å…¥ Redisï¼Œä¸ºä½ æœ€æ…¢çš„æŸ¥è¯¢ï¼ˆä¾‹å¦‚è·å–æ•´ä¸ªçœ‹æ¿çš„æ•°æ®ï¼‰æ·»åŠ ç¼“å­˜ã€‚

é˜¶æ®µ 7 (åŠŸèƒ½æ‰©å±•): å¼•å…¥ MongoDBï¼Œæ·»åŠ â€œæ“ä½œæ—¥å¿—â€åŠŸèƒ½ã€‚

é˜¶æ®µ 8 (è‡ªåŠ¨åŒ–): å­¦ä¹  GitHub Actionsï¼Œå®ç° CI/CD è‡ªåŠ¨åŒ–éƒ¨ç½²ã€‚

è¿™ä¸ªé¡¹ç›®è¶³å¤Ÿä½ å¿™ç¢Œå‡ ä¸ªæœˆï¼Œä½†å®Œæˆåï¼Œä½ å°†çœŸæ­£ç†è§£â€œå…¨æ ˆâ€çš„å«ä¹‰ã€‚



















Sprint 0: Environment Setup & Auth (Login/Register)

Sprint 1: Projects & Boards CRUD (Next Task)

Sprint 2: Lists & Cards CRUD

Sprint 3: Drag and Drop Implementation

Sprint 4: Real-time collaboration (WebSockets)















































Next Learning Path - Ranked by Backend Knowledge Gained

  PHASE 1: Real-Time Features (WebSockets) - HIGHEST LEARNING VALUE

  Backend Concepts: WebSockets, Socket.IO, event-driven architecture, real-time pub/sub

  Prompt for AI:
  I have a NestJS kanban board application with PostgreSQL. I want to add real-time collaboration using WebSockets.

  Current features: projects, cards, comments, notifications

  Implement:
  1. @nestjs/websockets gateway for real-time events
  2. Room-based connections (one room per project board)
  3. Real-time events:
     - card.created, card.updated, card.moved, card.deleted
     - comment.added
     - member.joined
     - list.created
  4. Frontend socket.io-client integration
  5. Auto-sync board state when other users make changes
  6. Show "User X is viewing this board" presence indicators

  Use Socket.IO with JWT authentication. Show me the gateway implementation, event handlers, and frontend hook.

  What You'll Learn: Event-driven architecture, bidirectional communication, connection management, broadcasting, rooms/namespaces

  ---
  PHASE 2: Activity Logging & Audit Trail

  Backend Concepts: Database design, event sourcing patterns, query optimization, pagination

  Prompt for AI:
  In my NestJS project, add an activity logging system to track all actions:

  Create an Activity entity to log:
  - User actions (created_card, updated_card, moved_card, added_comment, invited_member)
  - Project context
  - Old/new values (JSON metadata)
  - Timestamps

  Implement:
  1. ActivityLog entity with TypeORM
  2. ActivityService with decorators/interceptors to auto-log actions
  3. GET /api/projects/:id/activity endpoint with pagination
  4. Frontend activity feed component showing "John moved Card A from To Do to In Progress"

  Include proper indexes for performance and implement cursor-based pagination.

  What You'll Learn: Audit patterns, interceptors, decorators, pagination strategies, JSON columns, database indexing

  ---
  PHASE 3: Advanced Permissions & RBAC

  Backend Concepts: Role-Based Access Control, guards, authorization vs authentication

  Prompt for AI:
  Implement role-based permissions in my NestJS kanban app:

  Roles per project:
  - OWNER: full control, delete project
  - ADMIN: manage members, edit all cards
  - MEMBER: create/edit own cards, comment
  - VIEWER: read-only access

  Tasks:
  1. Create ProjectMember entity with role enum
  2. @Roles() decorator and RolesGuard
  3. Protect endpoints based on roles
  4. Update invitation system to assign roles
  5. Frontend: hide/disable actions based on user role

  Show me the guard implementation, decorator, and how to apply it to controllers.

  What You'll Learn: Custom guards, metadata reflection, authorization patterns, policy-based access control

  ---
  PHASE 4: Redis Caching Layer

  Backend Concepts: Caching strategies, Redis, performance optimization, cache invalidation

  Prompt for AI:
  Add Redis caching to my NestJS app to improve performance:

  Setup:
  1. @nestjs/cache-manager with redis-store
  2. Cache project details, list of cards
  3. Implement cache invalidation on updates
  4. Add cache-aside pattern for expensive queries

  Cache these endpoints:
  - GET /projects/:id (TTL: 5 minutes)
  - GET /lists/project/:projectId (TTL: 2 minutes)
  - User's project list (TTL: 1 minute)

  Show decorator-based caching and manual cache management. Include Redis connection config.

  What You'll Learn: Caching strategies, Redis data structures, TTL, cache invalidation, performance optimization

  ---
  PHASE 5: File Attachments on Cards

  Backend Concepts: File handling, storage strategies, streaming, cloud storage

  Prompt for AI:
  Add file attachment support to cards in my NestJS app:

  Features:
  1. Multiple file uploads per card (PDF, images, documents)
  2. File metadata entity (filename, size, mimetype, uploadedBy)
  3. POST /api/cards/:id/attachments with multer
  4. GET /api/cards/:id/attachments
  5. DELETE /api/cards/:id/attachments/:attachmentId
  6. File size validation (10MB limit)
  7. Generate thumbnails for images

  Use disk storage first, then show how to migrate to AWS S3 or MinIO.
  Frontend: file upload drag-and-drop component.

  What You'll Learn: File streaming, multer configuration, MIME types, image processing, cloud storage patterns

  ---
  PHASE 6: Due Dates & Reminders

  Backend Concepts: Scheduled tasks, cron jobs, background processing, queues

  Prompt for AI:
  Add due dates and reminder system to my NestJS kanban app:

  1. Add dueDate field to Card entity
  2. Create ReminderService with @nestjs/schedule
  3. Cron job to check overdue cards every hour
  4. Create notifications for cards due within 24 hours
  5. Email notifications using @nestjs-modules/mailer
  6. Bull queue for background email processing

  Include:
  - Overdue card indicator on frontend
  - Email notification when card is 1 day from due
  - Settings for user notification preferences

  What You'll Learn: Cron jobs, task scheduling, queues (Bull/BullMQ), email integration, background processing

  ---
  PHASE 7: Search & Filtering

  Backend Concepts: Full-text search, query building, database indexes, search optimization

  Prompt for AI:
  Implement search and filtering in my NestJS app:

  Search across:
  - Card titles and descriptions
  - Comments
  - Project names

  Features:
  1. GET /api/search?q=query&filters[]=type&projectId=123
  2. PostgreSQL full-text search with tsvector
  3. Filter by: assigned user, labels, due date, completion status
  4. Implement search indexes
  5. Return grouped results (projects, cards, comments)

  Frontend: search bar with instant results dropdown, advanced filter panel.

  What You'll Learn: Full-text search, PostgreSQL tsvector, query builders, complex filtering, database indexes

  ---
  PHASE 8: Email Notifications

  Backend Concepts: Email templating, async processing, queues, external service integration

  Prompt for AI:
  Add email notification system to my NestJS app:

  Setup @nestjs-modules/mailer with:
  1. Nodemailer for SMTP
  2. Handlebars email templates
  3. Queue-based sending with Bull

  Email triggers:
  - Project invitation
  - Card assignment
  - @mention in comments
  - Due date reminders

  Include:
  - Email template system
  - User notification preferences (opt-in/opt-out)
  - Batch digest emails (daily summary)
  - Email service abstraction for future provider changes

  What You'll Learn: Email integration, template engines, async processing, queue patterns, service abstraction

  ---
  PHASE 9: API Rate Limiting & Security

  Backend Concepts: Rate limiting, security headers, input sanitization, API security

  Prompt for AI:
  Harden security in my NestJS app:

  1. @nestjs/throttler for rate limiting
     - Global: 100 requests/15 min
     - Login endpoint: 5 attempts/15 min
  2. Helmet.js for security headers
  3. Input sanitization to prevent XSS
  4. SQL injection prevention verification
  5. CSRF protection for state-changing operations
  6. API key authentication for webhooks
  7. Request logging middleware

  Show configuration and custom decorators for endpoint-specific limits.

  What You'll Learn: API security, rate limiting, middleware, security headers, attack prevention

  ---
  PHASE 10: Testing & Documentation

  Backend Concepts: Unit testing, integration testing, E2E testing, API documentation

  Prompt for AI:
  Add comprehensive testing to my NestJS app:

  1. Unit tests for services using Jest
  2. Integration tests for controllers with supertest
  3. E2E tests for critical flows (auth, create project, move cards)
  4. Test database setup with docker-compose
  5. Swagger/OpenAPI documentation with @nestjs/swagger
  6. Coverage reports

  Focus on:
  - AuthService tests (login, register)
  - CardService tests (CRUD, reorder logic)
  - ProjectController E2E tests

  Show me testing best practices and mocking strategies.

  What You'll Learn: Testing strategies, mocking, test databases, coverage, API documentation, Swagger

  ---
  Recommended Order for Maximum Learning

  Beginner-friendly progression:
  1. Activity Logging (easier, teaches patterns)
  2. File Attachments (practical, visual results)
  3. Due Dates & Reminders (introduces cron/queues)
  4. Real-Time WebSockets (most exciting, moderate difficulty)
  5. Redis Caching (performance optimization)
  6. Advanced Permissions (security concepts)
  7. Search & Filtering (database skills)
  8. Email Notifications (integrations)
  9. Rate Limiting (production hardening)
  10. Testing (professional practices)

  Additional Learning Resources

  After these features, explore:
  - GraphQL (instead of REST): @nestjs/graphql
  - Microservices: Split into auth-service, project-service
  - Docker Compose Production: Multi-stage builds
  - CI/CD: GitHub Actions, automated testing
  - Monitoring: Prometheus, Grafana, Sentry
  - Database Migrations: TypeORM migrations instead of sync:true

  Quick Wins (Start Here)

  Pick ONE to start this week:

  Option A - Activity Log (Best for learning backend patterns)
  Option B - WebSockets (Most impactful for users)
  Option C - File Attachments (Easy to understand, visual)